; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\eeprom_emulate.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\eeprom_emulate.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -I..\..\Template -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\eeprom_emulate.crf ..\EEPROM_Emulate.c]
                          THUMB

                          AREA ||i.FMC_Enable||, CODE, READONLY, ALIGN=2

                  FMC_Enable PROC
;;;19       */
;;;20     void FMC_Enable(void)
000000  2159              MOVS     r1,#0x59
;;;21     {
000002  b510              PUSH     {r4,lr}
000004  0788              LSLS     r0,r1,#30
000006  2216              MOVS     r2,#0x16
000008  2388              MOVS     r3,#0x88
                  |L1.10|
00000a  f8c01100          STR      r1,[r0,#0x100]
00000e  f8c02100          STR      r2,[r0,#0x100]
000012  f8c03100          STR      r3,[r0,#0x100]
000016  f8d04100          LDR      r4,[r0,#0x100]
00001a  2c00              CMP      r4,#0
00001c  d0f5              BEQ      |L1.10|
;;;22     		/* Unlock protected registers for ISP function */
;;;23     		SYS_UnlockReg();
;;;24         
;;;25     //		CLK->AHBCLK |= CLK_AHBCLK_ISP_EN_Msk;
;;;26     //		/* Enable ISP function */
;;;27     //		FMC->ISPCON |= FMC_ISPCON_ISPEN_Msk;
;;;28     
;;;29     		CLK->AHBCLK |= CLK_AHBCLK_ISPCKEN_Msk;
00001e  f8d01204          LDR      r1,[r0,#0x204]
000022  f0410104          ORR      r1,r1,#4
000026  f8c01204          STR      r1,[r0,#0x204]
;;;30     		/* Enable ISP function */
;;;31     		FMC->ISPCTL |= FMC_ISPCTL_ISPEN_Msk;
00002a  4803              LDR      r0,|L1.56|
00002c  6801              LDR      r1,[r0,#0]
00002e  f0410101          ORR      r1,r1,#1
000032  6001              STR      r1,[r0,#0]
;;;32     
;;;33     }
000034  bd10              POP      {r4,pc}
;;;34     
                          ENDP

000036  0000              DCW      0x0000
                  |L1.56|
                          DCD      0x4000c000

                          AREA ||i.Get_Cycle_Counter||, CODE, READONLY, ALIGN=2

                  Get_Cycle_Counter PROC
;;;344      */
;;;345    uint16_t Get_Cycle_Counter(void)
000000  4805              LDR      r0,|L2.24|
;;;346    {
000002  b510              PUSH     {r4,lr}
;;;347    		uint16_t Cycle_Counter;
;;;348    	
;;;349    		/* Get the cycle counter from first two bytes in current Data Flash page */
;;;350    		Cycle_Counter = (uint16_t)FMC_Read(DataFlash_BaseAddr + (FMC_FLASH_PAGE_SIZE * Current_Valid_Page));
000004  6940              LDR      r0,[r0,#0x14]
000006  4905              LDR      r1,|L2.28|
000008  6809              LDR      r1,[r1,#0]  ; Current_Valid_Page
00000a  eb003001          ADD      r0,r0,r1,LSL #12
00000e  f7fffffe          BL       FMC_Read
000012  b280              UXTH     r0,r0
;;;351    	
;;;352    		return Cycle_Counter;
;;;353    }
000014  bd10              POP      {r4,pc}
                          ENDP

000016  0000              DCW      0x0000
                  |L2.24|
                          DCD      0x4000c000
                  |L2.28|
                          DCD      ||.data||

                          AREA ||i.Init_EEPROM||, CODE, READONLY, ALIGN=2

                  Init_EEPROM PROC
;;;42       */
;;;43     uint32_t Init_EEPROM(uint32_t data_amount, uint32_t use_pages)
000000  b510              PUSH     {r4,lr}
;;;44     {
;;;45     		uint32_t i;
;;;46     	
;;;47     		/* The amount of data includes 1 byte address and 1 byte data */
;;;48     		Amount_of_Data = data_amount;
000002  4c0c              LDR      r4,|L3.52|
;;;49     		/* The amount of page which user want to use */
;;;50     		Amount_Pages = use_pages;
;;;51     
;;;52     		/* Check setting is valid or not */
;;;53     		/* The amount of user's data is more than the maximun amount or not */
;;;54     		if(Amount_of_Data > Max_Amount_of_Data)
000004  2880              CMP      r0,#0x80
000006  e9c41001          STRD     r1,r0,[r4,#4]
00000a  d901              BLS      |L3.16|
;;;55     				return	Err_OverAmountData;
00000c  2001              MOVS     r0,#1
;;;56     		/* For M051 Series, the max. amount of Data Flash pages is 8 */
;;;57     		if(Amount_Pages > 8)
;;;58     				return	Err_OverPageAmount;		
;;;59     
;;;60     		/* Init SRAM for data */
;;;61     		Written_Data = (uint8_t *)malloc(sizeof(uint8_t) * Amount_of_Data);
;;;62     		/* Fill initial data 0xFF*/
;;;63     		for(i = 0; i < Amount_of_Data; i++)
;;;64     		{
;;;65     				Written_Data[i] = 0xFF;
;;;66     		}
;;;67     		
;;;68     		return 0;
;;;69     }
00000e  bd10              POP      {r4,pc}
                  |L3.16|
000010  2908              CMP      r1,#8                 ;57
000012  d901              BLS      |L3.24|
000014  2002              MOVS     r0,#2                 ;58
000016  bd10              POP      {r4,pc}
                  |L3.24|
000018  f7fffffe          BL       malloc
00001c  2100              MOVS     r1,#0                 ;63
00001e  22ff              MOVS     r2,#0xff              ;65
000020  6120              STR      r0,[r4,#0x10]         ;63  ; Written_Data
000022  e001              B        |L3.40|
                  |L3.36|
000024  5442              STRB     r2,[r0,r1]            ;65
000026  1c49              ADDS     r1,r1,#1              ;65
                  |L3.40|
000028  68a3              LDR      r3,[r4,#8]            ;63  ; Amount_of_Data
00002a  4299              CMP      r1,r3                 ;63
00002c  d3fa              BCC      |L3.36|
00002e  2000              MOVS     r0,#0                 ;68
000030  bd10              POP      {r4,pc}
;;;70     
                          ENDP

000032  0000              DCW      0x0000
                  |L3.52|
                          DCD      ||.data||

                          AREA ||i.Manage_Next_Page||, CODE, READONLY, ALIGN=2

                  Manage_Next_Page PROC
;;;252      */
;;;253    void Manage_Next_Page(void)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;254    {
;;;255    		uint32_t i = 0, j, counter, temp = 0, data_flag = 0, new_page;
;;;256    
;;;257    		/* Copy the valid data (not 0xFF) from SRAM to new valid page */
;;;258    		/* Get counter from the first two bytes */
;;;259    		counter = FMC_Read(DataFlash_BaseAddr + (FMC_FLASH_PAGE_SIZE * Current_Valid_Page));
000004  f8dfa0e0          LDR      r10,|L4.232|
000008  2400              MOVS     r4,#0                 ;255
00000a  4625              MOV      r5,r4                 ;255
00000c  f8da1014          LDR      r1,[r10,#0x14]
000010  4626              MOV      r6,r4                 ;255
000012  f8df90d8          LDR      r9,|L4.236|
000016  46c8              MOV      r8,r9
000018  f8d90000          LDR      r0,[r9,#0]  ; Current_Valid_Page
00001c  eb013000          ADD      r0,r1,r0,LSL #12
000020  f7fffffe          BL       FMC_Read
000024  4607              MOV      r7,r0
;;;260    
;;;261    		/* If current valid page is the last page, choose the first page as valid page */
;;;262    		if((Current_Valid_Page + 1) == Amount_Pages)
000026  f8d80000          LDR      r0,[r8,#0]  ; Current_Valid_Page
00002a  f8d82004          LDR      r2,[r8,#4]  ; Amount_Pages
00002e  1c41              ADDS     r1,r0,#1
000030  4291              CMP      r1,r2
000032  d102              BNE      |L4.58|
;;;263    		{
;;;264    				new_page = 0;
000034  46a0              MOV      r8,r4
000036  1c7f              ADDS     r7,r7,#1
;;;265    				/* Add counter to record 1 E/W cycle finished for all pages */
;;;266    				counter++;
000038  e001              B        |L4.62|
                  |L4.58|
00003a  f1000801          ADD      r8,r0,#1
                  |L4.62|
;;;267    		}
;;;268    		else
;;;269    		{
;;;270    				new_page = Current_Valid_Page + 1;
;;;271    		}
;;;272    	
;;;273    		/* Enable FMC ISP function */
;;;274    		FMC_Enable();
00003e  f7fffffe          BL       FMC_Enable
;;;275    				
;;;276    		/* Copy first valid data */
;;;277    		while(1)
;;;278    		{
;;;279    				/* Not a valid data, skip */
;;;280    				if(Written_Data[i] == 0xFF)
000042  f8d90010          LDR      r0,[r9,#0x10]
                  |L4.70|
000046  5d02              LDRB     r2,[r0,r4]
000048  2aff              CMP      r2,#0xff
00004a  d010              BEQ      |L4.110|
;;;281    				{
;;;282    						i++;
;;;283    				}
;;;284    				/* Combine counter and first valid data, and write to new page */
;;;285    				else
;;;286    				{
;;;287    						counter &= ~(Even_Addr_Mask | Even_Data_Mask);
;;;288    						counter |= (i << Even_Addr_Pos) | (Written_Data[i] << Even_Data_Pos);
00004c  5d00              LDRB     r0,[r0,r4]
00004e  0423              LSLS     r3,r4,#16
000050  b2ba              UXTH     r2,r7                 ;287
000052  ea436100          ORR      r1,r3,r0,LSL #24
000056  4311              ORRS     r1,r1,r2
000058  46cb              MOV      r11,r9
;;;289    						FMC_Write(DataFlash_BaseAddr + (FMC_FLASH_PAGE_SIZE * new_page), counter);
00005a  f8da2014          LDR      r2,[r10,#0x14]
00005e  46d1              MOV      r9,r10
000060  eb023008          ADD      r0,r2,r8,LSL #12
000064  f7fffffe          BL       FMC_Write
;;;290    						i++;
;;;291    						break;
;;;292    				}
;;;293    		}
;;;294    		/* Copy the rest of data */
;;;295    		for(j = 4; i < Amount_of_Data; i++)
000068  2704              MOVS     r7,#4
00006a  46da              MOV      r10,r11               ;259
00006c  e015              B        |L4.154|
                  |L4.110|
00006e  1c64              ADDS     r4,r4,#1              ;291
000070  e7e9              B        |L4.70|
                  |L4.114|
;;;296    		{
;;;297    				/* Not a valid data, skip */
;;;298    				if(Written_Data[i] == 0xFF)
000072  f8da0010          LDR      r0,[r10,#0x10]  ; Written_Data
000076  5d00              LDRB     r0,[r0,r4]
000078  28ff              CMP      r0,#0xff
00007a  d00e              BEQ      |L4.154|
;;;299    				{
;;;300    						continue;
;;;301    				}
;;;302    				/* Write to new page */
;;;303    				else
;;;304    				{
;;;305    						/* Collect two valid data and write to Data Flash */
;;;306    						/* First data, won't write to Data Flash immediately */
;;;307    						if(data_flag == 0)
00007c  b376              CBZ      r6,|L4.220|
;;;308    						{
;;;309    								temp |= (i << Odd_Addr_Pos) | (Written_Data[i] << Odd_Data_Pos);
;;;310    								data_flag = 1;
;;;311    						}
;;;312    						/* Second data, write to Data Flash after combine with first data */
;;;313    						else
;;;314    						{
;;;315    								temp |= (i << Even_Addr_Pos) | (Written_Data[i] << Even_Data_Pos);
00007e  0421              LSLS     r1,r4,#16
000080  ea416100          ORR      r1,r1,r0,LSL #24
;;;316    								FMC_Write(DataFlash_BaseAddr + (FMC_FLASH_PAGE_SIZE * new_page) + j, temp);
000084  f8d92014          LDR      r2,[r9,#0x14]
000088  4329              ORRS     r1,r1,r5              ;315
00008a  eb073008          ADD      r0,r7,r8,LSL #12
00008e  4410              ADD      r0,r0,r2
000090  f7fffffe          BL       FMC_Write
;;;317    								temp = 0;
000094  2500              MOVS     r5,#0
;;;318    								data_flag = 0;
000096  462e              MOV      r6,r5
000098  1d3f              ADDS     r7,r7,#4
                  |L4.154|
00009a  f8da1008          LDR      r1,[r10,#8]           ;295  ; Amount_of_Data
00009e  1c64              ADDS     r4,r4,#1
0000a0  4650              MOV      r0,r10                ;295
0000a2  428c              CMP      r4,r1                 ;295
0000a4  d3e5              BCC      |L4.114|
;;;319    								j += 4;
;;;320    						}
;;;321    				}				
;;;322    		}
;;;323    		
;;;324    		/* Set cursor to new page */
;;;325    		Current_Cursor = j;
0000a6  4604              MOV      r4,r0
;;;326    		
;;;327    		/* If there is one valid data left, write to Data Flash */
;;;328    		if(data_flag == 1)
0000a8  60c7              STR      r7,[r0,#0xc]  ; Current_Cursor
0000aa  b166              CBZ      r6,|L4.198|
;;;329    		{
;;;330    				temp |= 0xFFFF0000;
0000ac  4810              LDR      r0,|L4.240|
;;;331    				FMC_Write(DataFlash_BaseAddr + (FMC_FLASH_PAGE_SIZE * new_page) + j, temp);				
0000ae  f8d92014          LDR      r2,[r9,#0x14]
0000b2  ea450100          ORR      r1,r5,r0              ;330
0000b6  eb073008          ADD      r0,r7,r8,LSL #12
0000ba  4410              ADD      r0,r0,r2
0000bc  f7fffffe          BL       FMC_Write
;;;332    				Current_Cursor += 2;
0000c0  68e0              LDR      r0,[r4,#0xc]  ; Current_Cursor
0000c2  1c80              ADDS     r0,r0,#2
0000c4  60e0              STR      r0,[r4,#0xc]  ; Current_Cursor
                  |L4.198|
;;;333    		}
;;;334    		
;;;335    		/* Erase the old page */
;;;336    		FMC_Erase(DataFlash_BaseAddr + (FMC_FLASH_PAGE_SIZE * Current_Valid_Page));
0000c6  f8d90014          LDR      r0,[r9,#0x14]
0000ca  6821              LDR      r1,[r4,#0]  ; Current_Valid_Page
0000cc  eb003001          ADD      r0,r0,r1,LSL #12
0000d0  f7fffffe          BL       FMC_Erase
;;;337    		/* Point to new valid page */
;;;338    		Current_Valid_Page = new_page;
;;;339    }
0000d4  f8c48000          STR      r8,[r4,#0]  ; Current_Valid_Page
0000d8  e8bd9ff0          POP      {r4-r12,pc}
                  |L4.220|
0000dc  ea442000          ORR      r0,r4,r0,LSL #8       ;309
0000e0  4305              ORRS     r5,r5,r0              ;309
0000e2  2601              MOVS     r6,#1                 ;310
0000e4  e7d9              B        |L4.154|
;;;340    
                          ENDP

0000e6  0000              DCW      0x0000
                  |L4.232|
                          DCD      0x4000c000
                  |L4.236|
                          DCD      ||.data||
                  |L4.240|
                          DCD      0xffff0000

                          AREA ||i.Read_Data||, CODE, READONLY, ALIGN=2

                  Read_Data PROC
;;;168      */
;;;169    uint32_t Read_Data(uint8_t index, uint8_t *data)
000000  2880              CMP      r0,#0x80
;;;170    {
000002  d301              BCC      |L5.8|
;;;171    	
;;;172    		/* Check the index is valid or not */
;;;173    		if(index >= Max_Amount_of_Data)
;;;174    		{
;;;175    				return Err_ErrorIndex;
000004  2003              MOVS     r0,#3
;;;176    		}
;;;177    		
;;;178    		/* Get the data from SRAM */
;;;179    		*data = Written_Data[index];
;;;180    		
;;;181    		return 0;
;;;182    }
000006  4770              BX       lr
                  |L5.8|
000008  4a02              LDR      r2,|L5.20|
00000a  6912              LDR      r2,[r2,#0x10]         ;179  ; Written_Data
00000c  5c10              LDRB     r0,[r2,r0]            ;179
00000e  7008              STRB     r0,[r1,#0]            ;179
000010  2000              MOVS     r0,#0                 ;181
000012  4770              BX       lr
;;;183    
                          ENDP

                  |L5.20|
                          DCD      ||.data||

                          AREA ||i.Search_Valid_Page||, CODE, READONLY, ALIGN=2

                  Search_Valid_Page PROC
;;;73       */
;;;74     void Search_Valid_Page(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;75     {
;;;76     		uint32_t i, temp;
;;;77     		uint8_t	addr, data;
;;;78     		uint16_t	*Page_Status_ptr;
;;;79     
;;;80     		/* Enable FMC ISP function */
;;;81     		FMC_Enable();
000004  f7fffffe          BL       FMC_Enable
;;;82     	
;;;83     		/* Set information of each pages to Page_Status */
;;;84     		Page_Status_ptr = (uint16_t *)malloc(sizeof(uint16_t) * Amount_Pages);
000008  4e2a              LDR      r6,|L6.180|
00000a  6870              LDR      r0,[r6,#4]  ; Amount_Pages
00000c  0040              LSLS     r0,r0,#1
00000e  f7fffffe          BL       malloc
000012  4607              MOV      r7,r0
;;;85     		for(i = 0; i < Amount_Pages; i++)
000014  2400              MOVS     r4,#0
;;;86     		{
;;;87     				Page_Status_ptr[i] = (uint16_t)FMC_Read(DataFlash_BaseAddr + (FMC_FLASH_PAGE_SIZE * i));
000016  4d28              LDR      r5,|L6.184|
000018  e007              B        |L6.42|
                  |L6.26|
00001a  6968              LDR      r0,[r5,#0x14]
00001c  eb003004          ADD      r0,r0,r4,LSL #12
000020  f7fffffe          BL       FMC_Read
000024  f8270014          STRH     r0,[r7,r4,LSL #1]
000028  1c64              ADDS     r4,r4,#1
                  |L6.42|
00002a  6871              LDR      r1,[r6,#4]            ;85  ; Amount_Pages
00002c  428c              CMP      r4,r1                 ;85
00002e  d3f4              BCC      |L6.26|
;;;88     		}
;;;89     	
;;;90     		/* Search which page has valid data */
;;;91     		for(i = 0; i < Amount_Pages; i++)
000030  2000              MOVS     r0,#0
;;;92     		{
;;;93     				if(Page_Status_ptr[i] != Status_Unwritten)
000032  f64f72ff          MOV      r2,#0xffff
000036  e005              B        |L6.68|
                  |L6.56|
000038  f8373010          LDRH     r3,[r7,r0,LSL #1]
00003c  4293              CMP      r3,r2
00003e  d000              BEQ      |L6.66|
;;;94     						Current_Valid_Page = i;
000040  6030              STR      r0,[r6,#0]  ; Current_Valid_Page
                  |L6.66|
000042  1c40              ADDS     r0,r0,#1
                  |L6.68|
000044  4288              CMP      r0,r1                 ;91
000046  d3f7              BCC      |L6.56|
;;;95     		}
;;;96     		/* If Data Flash is used for first time, set counter = 0 */
;;;97     		if(Page_Status_ptr[Current_Valid_Page] == Status_Unwritten)
000048  6830              LDR      r0,[r6,#0]  ; Current_Valid_Page
;;;98     		{
;;;99     				/* Set counter = 0 */
;;;100    				FMC_Write(DataFlash_BaseAddr + (FMC_FLASH_PAGE_SIZE * Current_Valid_Page), 0xFFFF0000);
;;;101    				/* Set cursor to current Data Flash address */
;;;102    				Current_Cursor = 2;
00004a  2402              MOVS     r4,#2
00004c  f8371010          LDRH     r1,[r7,r0,LSL #1]     ;97
000050  4291              CMP      r1,r2                 ;97
;;;103    		}
;;;104    		else
;;;105    		{
;;;106    				/* Search where is current cursor for the next data to write and get the data has been written */
;;;107    				/* Check even value */
;;;108    				temp = FMC_Read(DataFlash_BaseAddr + (FMC_FLASH_PAGE_SIZE * Current_Valid_Page));
000052  6969              LDR      r1,[r5,#0x14]
000054  eb013000          ADD      r0,r1,r0,LSL #12
000058  d103              BNE      |L6.98|
00005a  4918              LDR      r1,|L6.188|
00005c  f7fffffe          BL       FMC_Write
000060  e023              B        |L6.170|
                  |L6.98|
000062  f7fffffe          BL       FMC_Read
;;;109    				addr = (temp & Even_Addr_Mask) >> Even_Addr_Pos;
000066  f3c04107          UBFX     r1,r0,#16,#8
;;;110    				data = (temp & Even_Data_Mask) >> Even_Data_Pos;
00006a  0e00              LSRS     r0,r0,#24
;;;111    				/* Check Address is 0xFF (un-written) of not */
;;;112    				if(addr == 0xFF)
00006c  29ff              CMP      r1,#0xff
00006e  d01c              BEQ      |L6.170|
;;;113    				{
;;;114    						/* If Address is 0xFF, then set cursor to current Data Flash address */
;;;115    						Current_Cursor = 2;
;;;116    				}
;;;117    				else
;;;118    				{
;;;119    						/* Copy the address and data to SRAM */
;;;120    						Written_Data[addr] = data;
000070  6932              LDR      r2,[r6,#0x10]  ; Written_Data
;;;121    					
;;;122    						/* Check the whole Data Flash */
;;;123    						for(i = 4; i < FMC_FLASH_PAGE_SIZE; i += 4)
000072  2404              MOVS     r4,#4
000074  02a7              LSLS     r7,r4,#10
000076  5450              STRB     r0,[r2,r1]            ;120
                  |L6.120|
;;;124    						{
;;;125    								/* Check odd value */
;;;126    								temp = FMC_Read(DataFlash_BaseAddr + (FMC_FLASH_PAGE_SIZE * Current_Valid_Page) + i);
000078  6968              LDR      r0,[r5,#0x14]
00007a  6831              LDR      r1,[r6,#0]  ; Current_Valid_Page
00007c  eb043101          ADD      r1,r4,r1,LSL #12
000080  4408              ADD      r0,r0,r1
000082  f7fffffe          BL       FMC_Read
;;;127    								addr = (temp & Odd_Addr_Mask) >> Odd_Addr_Pos;
000086  b2c1              UXTB     r1,r0
;;;128    								data = (temp & Odd_Data_Mask) >> Odd_Data_Pos;
000088  f3c02307          UBFX     r3,r0,#8,#8
;;;129    								/* Check Address is 0xFF (un-written) of not */
;;;130    								if(addr == 0xFF)
00008c  29ff              CMP      r1,#0xff
00008e  d00c              BEQ      |L6.170|
;;;131    								{
;;;132    										/* If Address is 0xFF, then set cursor to current Data Flash address */
;;;133    										Current_Cursor = i;
;;;134    										break;
;;;135    								}
;;;136    								else
;;;137    								{
;;;138    										/* Copy the address and data to SRAM */
;;;139    										Written_Data[addr] = data;
000090  6932              LDR      r2,[r6,#0x10]  ; Written_Data
000092  5453              STRB     r3,[r2,r1]
;;;140    								}
;;;141    								
;;;142    								/* Check even value */
;;;143    								addr = (temp & Even_Addr_Mask) >> Even_Addr_Pos;
000094  f3c04107          UBFX     r1,r0,#16,#8
;;;144    								data = (temp & Even_Data_Mask) >> Even_Data_Pos;
000098  0e00              LSRS     r0,r0,#24
;;;145    								/* Check Address is 0xFF (un-written) of not */
;;;146    								if(addr == 0xFF)
00009a  29ff              CMP      r1,#0xff
00009c  d007              BEQ      |L6.174|
;;;147    								{
;;;148    										/* If Address is 0xFF, then set cursor to current Data Flash address */
;;;149    										Current_Cursor = i + 2;
;;;150    										break;
;;;151    								}
;;;152    								else
;;;153    								{
;;;154    										/* Copy the address and data to SRAM */
;;;155    										Written_Data[addr] = data;
00009e  1d24              ADDS     r4,r4,#4
0000a0  5450              STRB     r0,[r2,r1]
0000a2  42bc              CMP      r4,r7                 ;123
0000a4  d3e8              BCC      |L6.120|
                  |L6.166|
;;;156    								}
;;;157    						}
;;;158    				}
;;;159    		}
;;;160    }
0000a6  e8bd81f0          POP      {r4-r8,pc}
                  |L6.170|
0000aa  60f4              STR      r4,[r6,#0xc]          ;115  ; Current_Cursor
0000ac  e7fb              B        |L6.166|
                  |L6.174|
0000ae  1ca4              ADDS     r4,r4,#2
0000b0  e7fb              B        |L6.170|
;;;161    
                          ENDP

0000b2  0000              DCW      0x0000
                  |L6.180|
                          DCD      ||.data||
                  |L6.184|
                          DCD      0x4000c000
                  |L6.188|
                          DCD      0xffff0000

                          AREA ||i.Write_Data||, CODE, READONLY, ALIGN=2

                  Write_Data PROC
;;;192      */
;;;193    uint32_t Write_Data(uint8_t index, uint8_t data)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;194    {
;;;195    		uint32_t temp = 0;
;;;196    
;;;197    		/* Check the index is valid or not */
;;;198    		if(index > Amount_of_Data)
000004  4e1f              LDR      r6,|L7.132|
000006  4604              MOV      r4,r0                 ;194
000008  460d              MOV      r5,r1                 ;194
00000a  68b0              LDR      r0,[r6,#8]  ; Amount_of_Data
00000c  4284              CMP      r4,r0
00000e  d902              BLS      |L7.22|
;;;199    		{
;;;200    				return Err_ErrorIndex;
000010  2003              MOVS     r0,#3
                  |L7.18|
;;;201    		}
;;;202    		/* If the writing data equals to current data, the skip the write process */
;;;203    		if(Written_Data[index] == data)
;;;204    		{
;;;205    				return 0;
;;;206    		}
;;;207    	
;;;208    		/* Enable FMC ISP function */
;;;209    		FMC_Enable();
;;;210    	
;;;211    		/* Current cursor points to odd position*/
;;;212    		if((Current_Cursor & 0x3) == 0)
;;;213    		{
;;;214    				/* Write data to Data Flash */
;;;215    				temp = 0xFFFF0000 | (index << Odd_Addr_Pos) | (data << Odd_Data_Pos);
;;;216    				FMC_Write(DataFlash_BaseAddr + (FMC_FLASH_PAGE_SIZE * Current_Valid_Page) + Current_Cursor, temp);
;;;217    				/* Write data to SRAM */
;;;218    				Written_Data[index] = data;
;;;219    		}
;;;220    		/* Current cursor points to even position*/
;;;221    		else
;;;222    		{
;;;223    				/* Read the odd position data */
;;;224    				temp = FMC_Read(DataFlash_BaseAddr + (FMC_FLASH_PAGE_SIZE * Current_Valid_Page) + (Current_Cursor - 2));
;;;225    				/* Combine odd position data and even position data */
;;;226    				temp &= ~(Even_Addr_Mask | Even_Data_Mask);
;;;227    				temp |= (index << Even_Addr_Pos) | (data << Even_Data_Pos);
;;;228    				/* Write data to Data Flash */
;;;229    				FMC_Write(DataFlash_BaseAddr + (FMC_FLASH_PAGE_SIZE * Current_Valid_Page) + (Current_Cursor - 2), temp);
;;;230    				/* Write data to SRAM */
;;;231    				Written_Data[index] = data;
;;;232    		}
;;;233    		
;;;234    		/* If current cursor points to the last position, then execute Manage_Next_Page() */
;;;235    		if(Current_Cursor == (FMC_FLASH_PAGE_SIZE - 2))
;;;236    		{
;;;237    				/* Copy valid data to next page */
;;;238    				Manage_Next_Page();
;;;239    		}
;;;240    		/* Add current cursor */
;;;241    		else
;;;242    		{
;;;243    				/* Set current cursor to next position */
;;;244    				Current_Cursor += 2;
;;;245    		}
;;;246    		
;;;247    		return 0;
;;;248    }
000012  e8bd81f0          POP      {r4-r8,pc}
                  |L7.22|
000016  6930              LDR      r0,[r6,#0x10]         ;203  ; Written_Data
000018  5d00              LDRB     r0,[r0,r4]            ;203
00001a  42a8              CMP      r0,r5                 ;203
00001c  d024              BEQ      |L7.104|
00001e  f7fffffe          BL       FMC_Enable
000022  68f0              LDR      r0,[r6,#0xc]          ;212  ; Current_Cursor
000024  4f18              LDR      r7,|L7.136|
000026  0781              LSLS     r1,r0,#30             ;212
000028  d023              BEQ      |L7.114|
00002a  6979              LDR      r1,[r7,#0x14]         ;224
00002c  6832              LDR      r2,[r6,#0]            ;224  ; Current_Valid_Page
00002e  1e80              SUBS     r0,r0,#2              ;224
000030  eb013102          ADD      r1,r1,r2,LSL #12      ;224
000034  4408              ADD      r0,r0,r1              ;224
000036  f7fffffe          BL       FMC_Read
00003a  0421              LSLS     r1,r4,#16             ;227
00003c  b280              UXTH     r0,r0                 ;226
00003e  ea416105          ORR      r1,r1,r5,LSL #24      ;227
000042  4301              ORRS     r1,r1,r0              ;227
000044  6978              LDR      r0,[r7,#0x14]         ;229
000046  6832              LDR      r2,[r6,#0]            ;229  ; Current_Valid_Page
000048  eb003202          ADD      r2,r0,r2,LSL #12      ;229
00004c  68f0              LDR      r0,[r6,#0xc]          ;229  ; Current_Cursor
00004e  1e80              SUBS     r0,r0,#2              ;229
                  |L7.80|
000050  4410              ADD      r0,r0,r2              ;229
000052  f7fffffe          BL       FMC_Write
000056  6930              LDR      r0,[r6,#0x10]         ;231  ; Written_Data
000058  5505              STRB     r5,[r0,r4]            ;231
00005a  68f0              LDR      r0,[r6,#0xc]          ;235  ; Current_Cursor
00005c  f5a06170          SUB      r1,r0,#0xf00          ;235
000060  39fe              SUBS     r1,r1,#0xfe           ;235
000062  d003              BEQ      |L7.108|
000064  1c80              ADDS     r0,r0,#2              ;235
000066  60f0              STR      r0,[r6,#0xc]          ;244  ; Current_Cursor
                  |L7.104|
000068  2000              MOVS     r0,#0                 ;247
00006a  e7d2              B        |L7.18|
                  |L7.108|
00006c  f7fffffe          BL       Manage_Next_Page
000070  e7fa              B        |L7.104|
                  |L7.114|
000072  f5a43180          SUB      r1,r4,#0x10000        ;215
000076  697a              LDR      r2,[r7,#0x14]         ;216
000078  ea412105          ORR      r1,r1,r5,LSL #8       ;215
00007c  6833              LDR      r3,[r6,#0]            ;216  ; Current_Valid_Page
00007e  eb003003          ADD      r0,r0,r3,LSL #12      ;216
000082  e7e5              B        |L7.80|
;;;249    
                          ENDP

                  |L7.132|
                          DCD      ||.data||
                  |L7.136|
                          DCD      0x4000c000

                          AREA ||.data||, DATA, ALIGN=2

                  Current_Valid_Page
                          DCD      0x00000000
                  Amount_Pages
                          DCD      0x00000000
                  Amount_of_Data
                          DCD      0x00000000
                  Current_Cursor
                          DCD      0x00000000
                  Written_Data
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\EEPROM_Emulate.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_EEPROM_Emulate_c_bb55154a____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___16_EEPROM_Emulate_c_bb55154a____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_EEPROM_Emulate_c_bb55154a____REVSH|
#line 402
|__asm___16_EEPROM_Emulate_c_bb55154a____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___16_EEPROM_Emulate_c_bb55154a____RRX|
#line 587
|__asm___16_EEPROM_Emulate_c_bb55154a____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
