; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --cpu=Cortex-M4.fp --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M480\Include -I..\..\..\Library\StdDriver\inc -I..\..\Template -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\main.crf ..\main.c]
                          THUMB

                          AREA ||i.Emulate_EEPROM||, CODE, READONLY, ALIGN=1

                  Emulate_EEPROM PROC
;;;155    
;;;156    void Emulate_EEPROM(void)
000000  b510              PUSH     {r4,lr}
;;;157    {
;;;158    //    SYS_UnlockReg();
;;;159    
;;;160        /* Enable FMC ISP function */
;;;161    //    FMC_Open();
;;;162    
;;;163    	//need to manual set data flash address ?
;;;164    //    if (set_data_flash_base(DATA_FLASH_OFFSET) < 0)
;;;165    //    {
;;;166    //        printf("Failed to set Data Flash base address!\r\n");
;;;167    //    }
;;;168    
;;;169    	/* Test Init_EEPROM() */
;;;170    	Init_EEPROM(DATA_FLASH_AMOUNT, DATA_FLASH_PAGE);
000002  2102              MOVS     r1,#2
000004  2018              MOVS     r0,#0x18
000006  f7fffffe          BL       Init_EEPROM
;;;171    	Search_Valid_Page();	
00000a  e8bd4010          POP      {r4,lr}
00000e  f7ffbffe          B.W      Search_Valid_Page
;;;172    }
;;;173    
                          ENDP


                          AREA ||i.Emulate_EEPROM_Process||, CODE, READONLY, ALIGN=2

                  Emulate_EEPROM_Process PROC
;;;132    
;;;133    void Emulate_EEPROM_Process(void)
000000  b510              PUSH     {r4,lr}
;;;134    {
000002  b08a              SUB      sp,sp,#0x28
;;;135    	uint8_t string[] = "\r\nEmulate_EEPROM_Process finish !\r\n\r\n" ; 
000004  2228              MOVS     r2,#0x28
000006  a110              ADR      r1,|L2.72|
000008  4668              MOV      r0,sp
00000a  f7fffffe          BL       __aeabi_memcpy4
;;;136    
;;;137    	if (is_flag_set(flag_Read_Data))
00000e  4c18              LDR      r4,|L2.112|
000010  68a0              LDR      r0,[r4,#8]  ; BitFlag
000012  0780              LSLS     r0,r0,#30
000014  d50d              BPL      |L2.50|
;;;138    	{
;;;139    		set_flag(flag_Read_Data , DISABLE);
000016  68a0              LDR      r0,[r4,#8]  ; BitFlag
000018  f0200002          BIC      r0,r0,#2
00001c  60a0              STR      r0,[r4,#8]  ; BitFlag
;;;140    
;;;141    		Emulate_EEPROM_ReadTest();
00001e  f7fffffe          BL       Emulate_EEPROM_ReadTest
;;;142    		
;;;143    		UART_Write(UART0 , string , strlen((char*)string) );
000022  4668              MOV      r0,sp
000024  f7fffffe          BL       strlen
000028  4602              MOV      r2,r0
00002a  4669              MOV      r1,sp
00002c  4811              LDR      r0,|L2.116|
00002e  f7fffffe          BL       UART_Write
                  |L2.50|
;;;144    	}
;;;145    
;;;146    	if (is_flag_set(flag_Write_Data))
000032  68a0              LDR      r0,[r4,#8]  ; BitFlag
000034  0740              LSLS     r0,r0,#29
000036  d505              BPL      |L2.68|
;;;147    	{
;;;148    		set_flag(flag_Write_Data , DISABLE);
000038  68a0              LDR      r0,[r4,#8]  ; BitFlag
00003a  f0200004          BIC      r0,r0,#4
00003e  60a0              STR      r0,[r4,#8]  ; BitFlag
;;;149    
;;;150    		Emulate_EEPROM_WriteTest();
000040  f7fffffe          BL       Emulate_EEPROM_WriteTest
                  |L2.68|
;;;151    	}
;;;152    
;;;153    	
;;;154    }
000044  b00a              ADD      sp,sp,#0x28
000046  bd10              POP      {r4,pc}
;;;155    
                          ENDP

                  |L2.72|
000048  0d0a456d          DCB      "\r\nEmulate_EEPROM_Process finish !\r\n\r\n",0
00004c  756c6174
000050  655f4545
000054  50524f4d
000058  5f50726f
00005c  63657373
000060  2066696e
000064  69736820
000068  210d0a0d
00006c  0a00    
00006e  00                DCB      0
00006f  00                DCB      0
                  |L2.112|
                          DCD      ||.data||
                  |L2.116|
                          DCD      0x40070000

                          AREA ||i.Emulate_EEPROM_ReadTest||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  Emulate_EEPROM_ReadTest PROC
;;;107    
;;;108    void Emulate_EEPROM_ReadTest(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;109    {
;;;110    	uint8_t i = 0;
000002  2400              MOVS     r4,#0
;;;111    	uint8_t cnt = 0;
000004  4626              MOV      r6,r4
000006  f88d4000          STRB     r4,[sp,#0]
;;;112    
;;;113    	printf("%s\r\n" , __FUNCTION__);
00000a  4913              LDR      r1,|L3.88|
00000c  a013              ADR      r0,|L3.92|
00000e  f7fffffe          BL       __2printf
;;;114    
;;;115        SYS_UnlockReg();
000012  f7fffffe          BL       SYS_UnlockReg
;;;116        FMC_Open();
000016  f7fffffe          BL       FMC_Open
;;;117    
;;;118    	for (i = 0 ; i < DATA_FLASH_AMOUNT; i ++)
;;;119    	{
;;;120    		Read_Data(i%DATA_FLASH_AMOUNT, &cnt );
00001a  2518              MOVS     r5,#0x18
                  |L3.28|
00001c  fbb4f0f5          UDIV     r0,r4,r5
000020  fb054010          MLS      r0,r5,r0,r4
000024  4669              MOV      r1,sp
000026  f7fffffe          BL       Read_Data
;;;121    		printf("0x%2X , ", cnt);
00002a  f89d1000          LDRB     r1,[sp,#0]
00002e  a00d              ADR      r0,|L3.100|
000030  f7fffffe          BL       __2printf
;;;122    		if ((i+1)%8 ==0)
000034  0760              LSLS     r0,r4,#29
000036  f1b04f60          CMP      r0,#0xe0000000
00003a  d102              BNE      |L3.66|
;;;123    		{
;;;124    			printf("\r\n");
00003c  a00c              ADR      r0,|L3.112|
00003e  f7fffffe          BL       __2printf
                  |L3.66|
000042  1c64              ADDS     r4,r4,#1
000044  b2e4              UXTB     r4,r4                 ;118
000046  2c18              CMP      r4,#0x18              ;118
000048  d3e8              BCC      |L3.28|
;;;125    		}
;;;126    	}
;;;127    
;;;128        FMC_Close();
00004a  f7fffffe          BL       FMC_Close
00004e  f04f4080          MOV      r0,#0x40000000
000052  f8c06100          STR      r6,[r0,#0x100]
;;;129        SYS_LockReg();
;;;130    	
;;;131    }
000056  bdf8              POP      {r3-r7,pc}
;;;132    
                          ENDP

                  |L3.88|
                          DCD      ||.constdata||+0x19
                  |L3.92|
00005c  25730d0a          DCB      "%s\r\n",0
000060  00      
000061  00                DCB      0
000062  00                DCB      0
000063  00                DCB      0
                  |L3.100|
000064  30782532          DCB      "0x%2X , ",0
000068  58202c20
00006c  00      
00006d  00                DCB      0
00006e  00                DCB      0
00006f  00                DCB      0
                  |L3.112|
000070  0d0a00            DCB      "\r\n",0
000073  00                DCB      0

                          AREA ||i.Emulate_EEPROM_WriteTest||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_s
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_str
                  Emulate_EEPROM_WriteTest PROC
;;;85     
;;;86     void Emulate_EEPROM_WriteTest(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;87     {
;;;88     	uint8_t cnt = 0;
;;;89     	uint8_t i = 0;
;;;90     	static uint8_t incr_base = 0;
;;;91     
;;;92     	printf("%s , incr_base : 0x%2X\r\n" , __FUNCTION__ , incr_base);
000004  4e13              LDR      r6,|L4.84|
000006  2500              MOVS     r5,#0                 ;88
000008  462c              MOV      r4,r5                 ;89
00000a  7832              LDRB     r2,[r6,#0]  ; incr_base
00000c  4912              LDR      r1,|L4.88|
00000e  a013              ADR      r0,|L4.92|
000010  f7fffffe          BL       __2printf
;;;93     
;;;94         SYS_UnlockReg();
000014  f7fffffe          BL       SYS_UnlockReg
;;;95         FMC_Open();
000018  f7fffffe          BL       FMC_Open
;;;96     	
;;;97     	for (i = 0 ; i < DATA_FLASH_AMOUNT; i ++)
;;;98     	{
;;;99     		Write_Data(i%DATA_FLASH_AMOUNT, incr_base + (cnt++) );
00001c  2718              MOVS     r7,#0x18
                  |L4.30|
00001e  fbb4f0f7          UDIV     r0,r4,r7
000022  7831              LDRB     r1,[r6,#0]  ; incr_base
000024  fb074010          MLS      r0,r7,r0,r4
000028  4429              ADD      r1,r1,r5
00002a  1c6d              ADDS     r5,r5,#1
00002c  b2c9              UXTB     r1,r1
00002e  b2ed              UXTB     r5,r5
000030  f7fffffe          BL       Write_Data
000034  1c64              ADDS     r4,r4,#1
000036  b2e4              UXTB     r4,r4                 ;97
000038  2c18              CMP      r4,#0x18              ;97
00003a  d3f0              BCC      |L4.30|
;;;100    	}
;;;101    
;;;102    	incr_base++;	//incr_base += 0x10;
00003c  7830              LDRB     r0,[r6,#0]  ; incr_base
00003e  1c40              ADDS     r0,r0,#1
000040  7030              STRB     r0,[r6,#0]
;;;103    
;;;104        FMC_Close();
000042  f7fffffe          BL       FMC_Close
000046  f04f4180          MOV      r1,#0x40000000
00004a  2000              MOVS     r0,#0
00004c  f8c10100          STR      r0,[r1,#0x100]
;;;105        SYS_LockReg();
;;;106    }
000050  e8bd81f0          POP      {r4-r8,pc}
;;;107    
                          ENDP

                  |L4.84|
                          DCD      ||.data||
                  |L4.88|
                          DCD      ||.constdata||
                  |L4.92|
00005c  2573202c          DCB      "%s , incr_base : 0x%2X\r\n",0
000060  20696e63
000064  725f6261
000068  7365203a
00006c  20307825
000070  32580d0a
000074  00      
000075  00                DCB      0
000076  00                DCB      0
000077  00                DCB      0

                          AREA ||i.LED_Init||, CODE, READONLY, ALIGN=2

                  LED_Init PROC
;;;306    
;;;307    void LED_Init(void)
000000  b510              PUSH     {r4,lr}
;;;308    {
;;;309    	GPIO_SetMode(PH,BIT0,GPIO_MODE_OUTPUT);
000002  4c09              LDR      r4,|L5.40|
000004  2201              MOVS     r2,#1
000006  4611              MOV      r1,r2
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       GPIO_SetMode
;;;310    	GPIO_SetMode(PH,BIT1,GPIO_MODE_OUTPUT);
00000e  2201              MOVS     r2,#1
000010  2102              MOVS     r1,#2
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       GPIO_SetMode
;;;311    	GPIO_SetMode(PH,BIT2,GPIO_MODE_OUTPUT);
000018  4620              MOV      r0,r4
00001a  2201              MOVS     r2,#1
00001c  e8bd4010          POP      {r4,lr}
000020  2104              MOVS     r1,#4
000022  f7ffbffe          B.W      GPIO_SetMode
;;;312    	
;;;313    }
;;;314    
                          ENDP

000026  0000              DCW      0x0000
                  |L5.40|
                          DCD      0x400041c0

                          AREA ||i.NVIC_EnableIRQ||, CODE, READONLY, ALIGN=1

                  NVIC_EnableIRQ PROC
;;;1625    */
;;;1626   __STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
000000  f000021f          AND      r2,r0,#0x1f
;;;1627   {
;;;1628     NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  0940              LSRS     r0,r0,#5
00000a  0080              LSLS     r0,r0,#2
00000c  f10020e0          ADD      r0,r0,#0xe000e000
000010  f8c01100          STR      r1,[r0,#0x100]
;;;1629   }
000014  4770              BX       lr
;;;1630   
                          ENDP


                          AREA ||i.NVIC_SystemReset||, CODE, READONLY, ALIGN=2

                  NVIC_SystemReset PROC
;;;1789    */
;;;1790   __STATIC_INLINE void NVIC_SystemReset(void)
000000  f3bf8f4f          DSB      
;;;1791   {
;;;1792     __DSB();                                                          /* Ensure all outstanding memory accesses included
;;;1793                                                                          buffered write are completed before reset */
;;;1794     SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
000004  4805              LDR      r0,|L7.28|
000006  6801              LDR      r1,[r0,#0]
000008  4a05              LDR      r2,|L7.32|
00000a  f40161e0          AND      r1,r1,#0x700
00000e  4311              ORRS     r1,r1,r2
000010  6001              STR      r1,[r0,#0]
;;;1795                              (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
;;;1796                               SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
;;;1797     __DSB();                                                          /* Ensure completion of memory access */
000012  f3bf8f4f          DSB      
                  |L7.22|
;;;1798   
;;;1799     for(;;)                                                           /* wait until reset */
;;;1800     {
;;;1801       __NOP();
000016  bf00              NOP      
000018  e7fd              B        |L7.22|
;;;1802     }
;;;1803   }
;;;1804   
                          ENDP

00001a  0000              DCW      0x0000
                  |L7.28|
                          DCD      0xe000ed0c
                  |L7.32|
                          DCD      0x05fa0004

                          AREA ||i.SYS_Init||, CODE, READONLY, ALIGN=2

                  SYS_Init PROC
;;;314    
;;;315    void SYS_Init(void)
000000  b570              PUSH     {r4-r6,lr}
;;;316    {
;;;317        /*---------------------------------------------------------------------------------------------------------*/
;;;318        /* Init System Clock                                                                                       */
;;;319        /*---------------------------------------------------------------------------------------------------------*/
;;;320        /* Unlock protected registers */
;;;321        SYS_UnlockReg();
000002  f7fffffe          BL       SYS_UnlockReg
;;;322    
;;;323        /* Set XT1_OUT(PF.2) and XT1_IN(PF.3) to input mode */
;;;324        PF->MODE &= ~(GPIO_MODE_MODE2_Msk | GPIO_MODE_MODE3_Msk);
000006  f04f2040          MOV      r0,#0x40004000
00000a  f8d01140          LDR      r1,[r0,#0x140]
00000e  f02101f0          BIC      r1,r1,#0xf0
000012  f8c01140          STR      r1,[r0,#0x140]
;;;325    
;;;326        /* Enable External XTAL (4~24 MHz) */
;;;327        CLK_EnableXtalRC(CLK_PWRCTL_HXTEN_Msk);
000016  2001              MOVS     r0,#1
000018  f7fffffe          BL       CLK_EnableXtalRC
;;;328    
;;;329        /* Waiting for 12MHz clock ready */
;;;330        CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk);
00001c  2001              MOVS     r0,#1
00001e  f7fffffe          BL       CLK_WaitClockReady
;;;331    
;;;332        /* Set core clock as PLL_CLOCK from PLL */
;;;333        CLK_SetCoreClock(FREQ_192MHZ);
000022  4811              LDR      r0,|L8.104|
000024  f7fffffe          BL       CLK_SetCoreClock
;;;334        /* Set PCLK0/PCLK1 to HCLK/2 */
;;;335        CLK->PCLKDIV = (CLK_PCLKDIV_APB0DIV_DIV2 | CLK_PCLKDIV_APB1DIV_DIV2);
000028  2011              MOVS     r0,#0x11
00002a  0784              LSLS     r4,r0,#30
00002c  f8c40234          STR      r0,[r4,#0x234]
;;;336    
;;;337        /* Enable UART clock */
;;;338        CLK_EnableModuleClock(UART0_MODULE);
000030  4d0e              LDR      r5,|L8.108|
000032  4628              MOV      r0,r5
000034  f7fffffe          BL       CLK_EnableModuleClock
;;;339    
;;;340        /* Select UART clock source from HXT */
;;;341        CLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART0SEL_HXT, CLK_CLKDIV0_UART0(1));
000038  2200              MOVS     r2,#0
00003a  4611              MOV      r1,r2
00003c  4628              MOV      r0,r5
00003e  f7fffffe          BL       CLK_SetModuleClock
;;;342    
;;;343    	TIMER0_HW_Init();
000042  f7fffffe          BL       TIMER0_HW_Init
;;;344    	TIMER1_HW_Init();
000046  f7fffffe          BL       TIMER1_HW_Init
;;;345    	
;;;346        /* Update System Core Clock */
;;;347        /* User can use SystemCoreClockUpdate() to calculate SystemCoreClock. */
;;;348        SystemCoreClockUpdate();
00004a  f7fffffe          BL       SystemCoreClockUpdate
;;;349    
;;;350        /* Set GPB multi-function pins for UART0 RXD and TXD */
;;;351        SYS->GPB_MFPH &= ~(SYS_GPB_MFPH_PB12MFP_Msk | SYS_GPB_MFPH_PB13MFP_Msk);
00004e  6be0              LDR      r0,[r4,#0x3c]
000050  f420007f          BIC      r0,r0,#0xff0000
000054  63e0              STR      r0,[r4,#0x3c]
;;;352        SYS->GPB_MFPH |= (SYS_GPB_MFPH_PB12MFP_UART0_RXD | SYS_GPB_MFPH_PB13MFP_UART0_TXD);
000056  6be0              LDR      r0,[r4,#0x3c]
000058  f44000cc          ORR      r0,r0,#0x660000
00005c  63e0              STR      r0,[r4,#0x3c]
00005e  2000              MOVS     r0,#0
000060  f8c40100          STR      r0,[r4,#0x100]
;;;353    
;;;354        /* Lock protected registers */
;;;355        SYS_LockReg();
;;;356    }
000064  bd70              POP      {r4-r6,pc}
;;;357    
                          ENDP

000066  0000              DCW      0x0000
                  |L8.104|
                          DCD      0x0b71b000
                  |L8.108|
                          DCD      0x57803d10

                          AREA ||i.SYS_UnlockReg||, CODE, READONLY, ALIGN=1

                  SYS_UnlockReg PROC
;;;1584     */
;;;1585   __STATIC_INLINE void SYS_UnlockReg(void)
000000  2159              MOVS     r1,#0x59
;;;1586   {
000002  b510              PUSH     {r4,lr}
;;;1587       do
;;;1588       {
;;;1589           SYS->REGLCTL = 0x59UL;
000004  0788              LSLS     r0,r1,#30
;;;1590           SYS->REGLCTL = 0x16UL;
000006  2216              MOVS     r2,#0x16
;;;1591           SYS->REGLCTL = 0x88UL;
000008  2388              MOVS     r3,#0x88
                  |L9.10|
00000a  f8c01100          STR      r1,[r0,#0x100]        ;1589
00000e  f8c02100          STR      r2,[r0,#0x100]        ;1590
000012  f8c03100          STR      r3,[r0,#0x100]
;;;1592       }
;;;1593       while(SYS->REGLCTL == 0UL);
000016  f8d04100          LDR      r4,[r0,#0x100]
00001a  2c00              CMP      r4,#0
00001c  d0f5              BEQ      |L9.10|
;;;1594   }
00001e  bd10              POP      {r4,pc}
;;;1595   
                          ENDP


                          AREA ||i.TIMER0_HW_Init||, CODE, READONLY, ALIGN=2

                  TIMER0_HW_Init PROC
;;;295    
;;;296    void TIMER0_HW_Init(void)
000000  b510              PUSH     {r4,lr}
;;;297    {
;;;298    	CLK_EnableModuleClock(TMR0_MODULE);
000002  4c06              LDR      r4,|L10.28|
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       CLK_EnableModuleClock
;;;299    	CLK_SetModuleClock(TMR0_MODULE, CLK_CLKSEL1_TMR0SEL_PCLK0, 0);
00000a  4620              MOV      r0,r4
00000c  e8bd4010          POP      {r4,lr}
000010  2200              MOVS     r2,#0
000012  f44f7100          MOV      r1,#0x200
000016  f7ffbffe          B.W      CLK_SetModuleClock
;;;300    }
;;;301    
                          ENDP

00001a  0000              DCW      0x0000
                  |L10.28|
                          DCD      0x5e800002

                          AREA ||i.TIMER0_Polling||, CODE, READONLY, ALIGN=2

                  TIMER0_Polling PROC
;;;301    
;;;302    void TIMER0_Polling(uint32_t u32Usec)
000000  4601              MOV      r1,r0
;;;303    {
;;;304    	TIMER_Delay(TIMER0, u32Usec);
000002  4801              LDR      r0,|L11.8|
000004  f7ffbffe          B.W      TIMER_Delay
;;;305    }
;;;306    
                          ENDP

                  |L11.8|
                          DCD      0x40050000

                          AREA ||i.TIMER1_HW_Init||, CODE, READONLY, ALIGN=2

                  TIMER1_HW_Init PROC
;;;281    
;;;282    void TIMER1_HW_Init(void)
000000  b510              PUSH     {r4,lr}
;;;283    {
;;;284        CLK_EnableModuleClock(TMR1_MODULE);
000002  4c06              LDR      r4,|L12.28|
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       CLK_EnableModuleClock
;;;285        CLK_SetModuleClock(TMR1_MODULE, CLK_CLKSEL1_TMR1SEL_HIRC, 0);
00000a  4620              MOV      r0,r4
00000c  e8bd4010          POP      {r4,lr}
000010  2200              MOVS     r2,#0
000012  f44f41e0          MOV      r1,#0x7000
000016  f7ffbffe          B.W      CLK_SetModuleClock
;;;286    }
;;;287    
                          ENDP

00001a  0000              DCW      0x0000
                  |L12.28|
                          DCD      0x5ec00003

                          AREA ||i.TIMER1_Init||, CODE, READONLY, ALIGN=2

                  TIMER1_Init PROC
;;;287    
;;;288    void TIMER1_Init(void)
000000  b510              PUSH     {r4,lr}
;;;289    {
;;;290        TIMER_Open(TIMER1, TIMER_PERIODIC_MODE, 1000);
000002  4c0a              LDR      r4,|L13.44|
000004  f44f727a          MOV      r2,#0x3e8
000008  f04f6100          MOV      r1,#0x8000000
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       TIMER_Open
000012  6820              LDR      r0,[r4,#0]
000014  f0405000          ORR      r0,r0,#0x20000000
000018  6020              STR      r0,[r4,#0]
;;;291        TIMER_EnableInt(TIMER1);
;;;292        NVIC_EnableIRQ(TMR1_IRQn);	
00001a  2021              MOVS     r0,#0x21
00001c  f7fffffe          BL       NVIC_EnableIRQ
000020  6820              LDR      r0,[r4,#0]
000022  f0404080          ORR      r0,r0,#0x40000000
000026  6020              STR      r0,[r4,#0]
;;;293        TIMER_Start(TIMER1);
;;;294    }
000028  bd10              POP      {r4,pc}
;;;295    
                          ENDP

00002a  0000              DCW      0x0000
                  |L13.44|
                          DCD      0x40050100

                          AREA ||i.TMR1_IRQHandler||, CODE, READONLY, ALIGN=2

                  TMR1_IRQHandler PROC
;;;247    
;;;248    void TMR1_IRQHandler(void)
000000  4816              LDR      r0,|L14.92|
;;;249    {
000002  b510              PUSH     {r4,lr}
000004  6881              LDR      r1,[r0,#8]
000006  f3c10100          UBFX     r1,r1,#0,#1
00000a  2900              CMP      r1,#0
00000c  d025              BEQ      |L14.90|
00000e  2101              MOVS     r1,#1
000010  6081              STR      r1,[r0,#8]
;;;250    //	static uint32_t log = 0;	
;;;251    	static uint16_t CNT = 0;
;;;252    	static uint16_t CNT_read = 0;
;;;253    	static uint16_t CNT_write = 0;
;;;254    	
;;;255        if(TIMER_GetIntFlag(TIMER1) == 1)
;;;256        {
;;;257            TIMER_ClearIntFlag(TIMER1);
;;;258    	
;;;259    		if (CNT++ > 1000)
000012  4913              LDR      r1,|L14.96|
000014  8848              LDRH     r0,[r1,#2]  ; CNT
000016  1c42              ADDS     r2,r0,#1
000018  804a              STRH     r2,[r1,#2]
00001a  2200              MOVS     r2,#0
00001c  f5b07f7a          CMP      r0,#0x3e8
000020  d905              BLS      |L14.46|
;;;260    		{		
;;;261    			CNT = 0;
;;;262    //			printf("%s : %2d\r\n" , __FUNCTION__ , log++);
;;;263    
;;;264    			LED_G ^= 1;
000022  4810              LDR      r0,|L14.100|
000024  804a              STRH     r2,[r1,#2]            ;261
000026  6803              LDR      r3,[r0,#0]
000028  f0830301          EOR      r3,r3,#1
00002c  6003              STR      r3,[r0,#0]
                  |L14.46|
;;;265    		}
;;;266    
;;;267    		if (CNT_write++ >= 500)
00002e  88c8              LDRH     r0,[r1,#6]  ; CNT_write
000030  1c43              ADDS     r3,r0,#1
000032  80cb              STRH     r3,[r1,#6]
000034  f44f73fa          MOV      r3,#0x1f4
000038  4298              CMP      r0,r3
00003a  d304              BCC      |L14.70|
;;;268    		{		
;;;269    			CNT_write = 0;
00003c  80ca              STRH     r2,[r1,#6]
;;;270    			set_flag(flag_Write_Data , ENABLE);
00003e  6888              LDR      r0,[r1,#8]  ; BitFlag
000040  f0400004          ORR      r0,r0,#4
000044  6088              STR      r0,[r1,#8]  ; BitFlag
                  |L14.70|
;;;271    		}
;;;272    
;;;273    		if (CNT_read++ >= 500)
000046  8888              LDRH     r0,[r1,#4]  ; CNT_read
000048  1c44              ADDS     r4,r0,#1
00004a  808c              STRH     r4,[r1,#4]
00004c  4298              CMP      r0,r3
00004e  d304              BCC      |L14.90|
;;;274    		{		
;;;275    			CNT_read = 0;
000050  808a              STRH     r2,[r1,#4]
;;;276    			set_flag(flag_Read_Data , ENABLE);
000052  6888              LDR      r0,[r1,#8]  ; BitFlag
000054  f0400002          ORR      r0,r0,#2
000058  6088              STR      r0,[r1,#8]  ; BitFlag
                  |L14.90|
;;;277    		}	
;;;278    		
;;;279        }
;;;280    }
00005a  bd10              POP      {r4,pc}
;;;281    
                          ENDP

                  |L14.92|
                          DCD      0x40050100
                  |L14.96|
                          DCD      ||.data||
                  |L14.100|
                          DCD      0x400049c8

                          AREA ||i.UART0_IRQHandler||, CODE, READONLY, ALIGN=2

                  UART0_IRQHandler PROC
;;;206    
;;;207    void UART0_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;208    {
;;;209        if(UART_GET_INT_FLAG(UART0, UART_INTSTS_RDAINT_Msk | UART_INTSTS_RXTOINT_Msk))     /* UART receive data available flag */
000002  4c0b              LDR      r4,|L15.48|
000004  69e0              LDR      r0,[r4,#0x1c]
000006  f4105f88          TST      r0,#0x1100
00000a  d102              BNE      |L15.18|
00000c  e004              B        |L15.24|
                  |L15.14|
;;;210        {
;;;211            while(UART_GET_RX_EMPTY(UART0) == 0)
;;;212            {
;;;213    			UARTx_Process();
00000e  f7fffffe          BL       UARTx_Process
                  |L15.18|
000012  69a1              LDR      r1,[r4,#0x18]         ;211
000014  0449              LSLS     r1,r1,#17             ;211
000016  d5fa              BPL      |L15.14|
                  |L15.24|
;;;214            }
;;;215        }
;;;216    
;;;217        if(UART0->FIFOSTS & (UART_FIFOSTS_BIF_Msk | UART_FIFOSTS_FEF_Msk | UART_FIFOSTS_PEF_Msk | UART_FIFOSTS_RXOVIF_Msk))
000018  69a1              LDR      r1,[r4,#0x18]
00001a  4620              MOV      r0,r4
00001c  f0110f71          TST      r1,#0x71
000020  d005              BEQ      |L15.46|
;;;218        {
;;;219            UART_ClearIntFlag(UART0, (UART_INTSTS_RLSINT_Msk| UART_INTSTS_BUFERRINT_Msk));
000022  e8bd4010          POP      {r4,lr}
000026  f44f5110          MOV      r1,#0x2400
00002a  f7ffbffe          B.W      UART_ClearIntFlag
                  |L15.46|
;;;220        }
;;;221    }
00002e  bd10              POP      {r4,pc}
;;;222    
                          ENDP

                  |L15.48|
                          DCD      0x40070000

                          AREA ||i.UART0_Init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  UART0_Init PROC
;;;222    
;;;223    void UART0_Init(void)
000000  b510              PUSH     {r4,lr}
;;;224    {
;;;225        SYS_ResetModule(UART0_RST);
000002  481e              LDR      r0,|L16.124|
000004  f7fffffe          BL       SYS_ResetModule
;;;226    
;;;227        /* Configure UART0 and set UART0 baud rate */
;;;228        UART_Open(UART0, 115200);
000008  4c1d              LDR      r4,|L16.128|
00000a  f44f31e1          MOV      r1,#0x1c200
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       UART_Open
;;;229    
;;;230    	/* Set UART receive time-out */
;;;231    	UART_SetTimeoutCnt(UART0, 20);
000014  2114              MOVS     r1,#0x14
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       UART_SetTimeoutCnt
;;;232    
;;;233    	UART0->FIFO &= ~UART_FIFO_RFITL_4BYTES;
00001c  68a0              LDR      r0,[r4,#8]
00001e  f0200010          BIC      r0,r0,#0x10
000022  60a0              STR      r0,[r4,#8]
;;;234    	UART0->FIFO |= UART_FIFO_RFITL_8BYTES;
000024  68a0              LDR      r0,[r4,#8]
000026  f0400020          ORR      r0,r0,#0x20
00002a  60a0              STR      r0,[r4,#8]
;;;235    
;;;236    	/* Enable UART Interrupt - */
;;;237    	UART_ENABLE_INT(UART0, UART_INTEN_RDAIEN_Msk | UART_INTEN_TOCNTEN_Msk | UART_INTEN_RXTOIEN_Msk);
00002c  6860              LDR      r0,[r4,#4]
00002e  f6400111          MOV      r1,#0x811
000032  4308              ORRS     r0,r0,r1
000034  6060              STR      r0,[r4,#4]
;;;238    	
;;;239    	NVIC_EnableIRQ(UART0_IRQn);
000036  2024              MOVS     r0,#0x24
000038  f7fffffe          BL       NVIC_EnableIRQ
;;;240    
;;;241    	printf("\r\nCLK_GetCPUFreq : %8d\r\n",CLK_GetCPUFreq());
00003c  f7fffffe          BL       CLK_GetCPUFreq
000040  4601              MOV      r1,r0
000042  a010              ADR      r0,|L16.132|
000044  f7fffffe          BL       __2printf
;;;242    	printf("CLK_GetHXTFreq : %8d\r\n",CLK_GetHXTFreq());
000048  f7fffffe          BL       CLK_GetHXTFreq
00004c  4601              MOV      r1,r0
00004e  a014              ADR      r0,|L16.160|
000050  f7fffffe          BL       __2printf
;;;243    	printf("CLK_GetLXTFreq : %8d\r\n",CLK_GetLXTFreq());	
000054  f7fffffe          BL       CLK_GetLXTFreq
000058  4601              MOV      r1,r0
00005a  a017              ADR      r0,|L16.184|
00005c  f7fffffe          BL       __2printf
;;;244    	printf("CLK_GetPCLK0Freq : %8d\r\n",CLK_GetPCLK0Freq());
000060  f7fffffe          BL       CLK_GetPCLK0Freq
000064  4601              MOV      r1,r0
000066  a01a              ADR      r0,|L16.208|
000068  f7fffffe          BL       __2printf
;;;245    	printf("CLK_GetPCLK1Freq : %8d\r\n",CLK_GetPCLK1Freq());	
00006c  f7fffffe          BL       CLK_GetPCLK1Freq
000070  4601              MOV      r1,r0
000072  e8bd4010          POP      {r4,lr}
000076  a01d              ADR      r0,|L16.236|
000078  f7ffbffe          B.W      __2printf
;;;246    }
;;;247    
                          ENDP

                  |L16.124|
                          DCD      0x04000010
                  |L16.128|
                          DCD      0x40070000
                  |L16.132|
000084  0d0a434c          DCB      "\r\nCLK_GetCPUFreq : %8d\r\n",0
000088  4b5f4765
00008c  74435055
000090  46726571
000094  203a2025
000098  38640d0a
00009c  00      
00009d  00                DCB      0
00009e  00                DCB      0
00009f  00                DCB      0
                  |L16.160|
0000a0  434c4b5f          DCB      "CLK_GetHXTFreq : %8d\r\n",0
0000a4  47657448
0000a8  58544672
0000ac  6571203a
0000b0  20253864
0000b4  0d0a00  
0000b7  00                DCB      0
                  |L16.184|
0000b8  434c4b5f          DCB      "CLK_GetLXTFreq : %8d\r\n",0
0000bc  4765744c
0000c0  58544672
0000c4  6571203a
0000c8  20253864
0000cc  0d0a00  
0000cf  00                DCB      0
                  |L16.208|
0000d0  434c4b5f          DCB      "CLK_GetPCLK0Freq : %8d\r\n",0
0000d4  47657450
0000d8  434c4b30
0000dc  46726571
0000e0  203a2025
0000e4  38640d0a
0000e8  00      
0000e9  00                DCB      0
0000ea  00                DCB      0
0000eb  00                DCB      0
                  |L16.236|
0000ec  434c4b5f          DCB      "CLK_GetPCLK1Freq : %8d\r\n",0
0000f0  47657450
0000f4  434c4b31
0000f8  46726571
0000fc  203a2025
000100  38640d0a
000104  00      
000105  00                DCB      0
000106  00                DCB      0
000107  00                DCB      0

                          AREA ||i.UARTx_Process||, CODE, READONLY, ALIGN=2

                  UARTx_Process PROC
;;;173    
;;;174    void UARTx_Process(void)
000000  4811              LDR      r0,|L17.72|
;;;175    {
000002  b510              PUSH     {r4,lr}
;;;176    	uint8_t res = 0;
;;;177    	
;;;178    	res = UART_READ(UART0);
000004  6800              LDR      r0,[r0,#0]
000006  b2c0              UXTB     r0,r0
;;;179    
;;;180    	if (res > 0x7F)
000008  287f              CMP      r0,#0x7f
00000a  d904              BLS      |L17.22|
;;;181    	{
;;;182    		printf("invalid command\r\n");
00000c  e8bd4010          POP      {r4,lr}
000010  a00e              ADR      r0,|L17.76|
000012  f7ffbffe          B.W      __2printf
                  |L17.22|
;;;183    	}
;;;184    	else
;;;185    	{
;;;186    		switch(res)
000016  285a              CMP      r0,#0x5a
000018  d00b              BEQ      |L17.50|
00001a  dc06              BGT      |L17.42|
00001c  2831              CMP      r0,#0x31
00001e  d00a              BEQ      |L17.54|
000020  2832              CMP      r0,#0x32
000022  d00c              BEQ      |L17.62|
000024  2858              CMP      r0,#0x58
000026  d10e              BNE      |L17.70|
000028  e003              B        |L17.50|
                  |L17.42|
00002a  2878              CMP      r0,#0x78
00002c  d001              BEQ      |L17.50|
00002e  287a              CMP      r0,#0x7a
000030  d109              BNE      |L17.70|
                  |L17.50|
;;;187    		{
;;;188    			case '1':
;;;189    				Emulate_EEPROM_ReadTest();
;;;190    				break;	
;;;191    			case '2':
;;;192    				Emulate_EEPROM_WriteTest();
;;;193    				break;	
;;;194    			
;;;195    			case 'X':
;;;196    			case 'x':
;;;197    			case 'Z':
;;;198    			case 'z':
;;;199    				NVIC_SystemReset();
000032  f7fffffe          BL       NVIC_SystemReset
                  |L17.54|
000036  e8bd4010          POP      {r4,lr}               ;189
00003a  f7ffbffe          B.W      Emulate_EEPROM_ReadTest
                  |L17.62|
00003e  e8bd4010          POP      {r4,lr}               ;192
000042  f7ffbffe          B.W      Emulate_EEPROM_WriteTest
                  |L17.70|
;;;200    			
;;;201    				break;		
;;;202    			
;;;203    		}
;;;204    	}
;;;205    }
000046  bd10              POP      {r4,pc}
;;;206    
                          ENDP

                  |L17.72|
                          DCD      0x40070000
                  |L17.76|
00004c  696e7661          DCB      "invalid command\r\n",0
000050  6c696420
000054  636f6d6d
000058  616e640d
00005c  0a00    
00005e  00                DCB      0
00005f  00                DCB      0

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;365    
;;;366    int main()
000000  f7fffffe          BL       SYS_Init
;;;367    {	
;;;368    
;;;369        SYS_Init();
;;;370    	UART0_Init();
000004  f7fffffe          BL       UART0_Init
;;;371    
;;;372    	Emulate_EEPROM();
000008  f7fffffe          BL       Emulate_EEPROM
;;;373    	
;;;374    	LED_Init();
00000c  f7fffffe          BL       LED_Init
;;;375    	TIMER1_Init();
000010  f7fffffe          BL       TIMER1_Init
;;;376    
;;;377        /* Got no where to go, just loop forever */
;;;378        while(1)
;;;379        {
;;;380    //		TIMER0_Polling(1000);
;;;381    
;;;382    //		Emulate_EEPROM_Process();
;;;383    		LED_Y ^= 1;	
000014  4802              LDR      r0,|L18.32|
                  |L18.22|
000016  6801              LDR      r1,[r0,#0]
000018  f0810101          EOR      r1,r1,#1
00001c  6001              STR      r1,[r0,#0]
00001e  e7fa              B        |L18.22|
;;;384        }
;;;385    }
;;;386    
                          ENDP

                  |L18.32|
                          DCD      0x400049c4

                          AREA ||i.set_data_flash_base||, CODE, READONLY, ALIGN=2

                  set_data_flash_base PROC
;;;42     
;;;43     int set_data_flash_base(uint32_t u32DFBA)
000000  b57c              PUSH     {r2-r6,lr}
;;;44     {
000002  4604              MOV      r4,r0
;;;45         uint32_t   au32Config[2];          /* User Configuration */
;;;46     
;;;47         SYS_UnlockReg();
000004  f7fffffe          BL       SYS_UnlockReg
;;;48         /* Enable FMC ISP function */
;;;49         FMC_Open();
000008  f7fffffe          BL       FMC_Open
;;;50     
;;;51         /* Check if Data Flash Size is 64K. If not, to re-define Data Flash size and to enable Data Flash function */
;;;52         if (FMC_ReadConfig(au32Config, 2) < 0)
00000c  2102              MOVS     r1,#2
00000e  4668              MOV      r0,sp
000010  f7fffffe          BL       FMC_ReadConfig
;;;53             return -1;
000014  f04f35ff          MOV      r5,#0xffffffff
000018  2800              CMP      r0,#0                 ;52
00001a  db18              BLT      |L19.78|
;;;54     
;;;55         if (((au32Config[0] & 0x01) == 1) || (au32Config[1] != u32DFBA) )
00001c  9800              LDR      r0,[sp,#0]
00001e  07c0              LSLS     r0,r0,#31
000020  d102              BNE      |L19.40|
000022  9801              LDR      r0,[sp,#4]
000024  42a0              CMP      r0,r4
000026  d02e              BEQ      |L19.134|
                  |L19.40|
;;;56         {
;;;57             FMC_ENABLE_CFG_UPDATE();
000028  4818              LDR      r0,|L19.140|
00002a  6801              LDR      r1,[r0,#0]
00002c  f0410110          ORR      r1,r1,#0x10
000030  6001              STR      r1,[r0,#0]
;;;58     		
;;;59     		FMC_Erase(FMC_CONFIG_BASE);
000032  0180              LSLS     r0,r0,#6
000034  f7fffffe          BL       FMC_Erase
;;;60     		
;;;61             au32Config[0] &= ~0x1;
000038  9800              LDR      r0,[sp,#0]
;;;62             au32Config[1] = u32DFBA;
;;;63             if (FMC_WriteConfig(au32Config, 2) < 0)
00003a  2102              MOVS     r1,#2
00003c  f0200001          BIC      r0,r0,#1              ;61
000040  e9cd0400          STRD     r0,r4,[sp,#0]
000044  4668              MOV      r0,sp
000046  f7fffffe          BL       FMC_WriteConfig
00004a  2800              CMP      r0,#0
00004c  da01              BGE      |L19.82|
                  |L19.78|
;;;64                 return -1;
00004e  4628              MOV      r0,r5
;;;65     
;;;66             FMC_ReadConfig(au32Config, 2);
;;;67             if (((au32Config[0] & 0x01) == 1) || (au32Config[1] != u32DFBA))
;;;68             {
;;;69                 printf("Error: Program Config Failed!\n");
;;;70                 /* Disable FMC ISP function */
;;;71                 FMC_Close();
;;;72                 SYS_LockReg();
;;;73                 return -1;
;;;74             }
;;;75     
;;;76             printf("chip reset\n");
;;;77             /* Reset Chip to reload new CONFIG value */
;;;78             //SYS->IPRST0 = SYS_IPRST0_CHIPRST_Msk;
;;;79             NVIC_SystemReset();
;;;80         }
;;;81     	
;;;82         return 0;                          /* success */
;;;83     }
000050  bd7c              POP      {r2-r6,pc}
                  |L19.82|
000052  2102              MOVS     r1,#2                 ;66
000054  4668              MOV      r0,sp                 ;66
000056  f7fffffe          BL       FMC_ReadConfig
00005a  9800              LDR      r0,[sp,#0]            ;67
00005c  07c0              LSLS     r0,r0,#31             ;67
00005e  d102              BNE      |L19.102|
000060  9801              LDR      r0,[sp,#4]            ;67
000062  42a0              CMP      r0,r4                 ;67
000064  d00a              BEQ      |L19.124|
                  |L19.102|
000066  a00a              ADR      r0,|L19.144|
000068  f7fffffe          BL       __2printf
00006c  f7fffffe          BL       FMC_Close
000070  f04f4180          MOV      r1,#0x40000000        ;71
000074  2000              MOVS     r0,#0                 ;71
000076  f8c10100          STR      r0,[r1,#0x100]        ;71
00007a  e7e8              B        |L19.78|
                  |L19.124|
00007c  a00c              ADR      r0,|L19.176|
00007e  f7fffffe          BL       __2printf
000082  f7fffffe          BL       NVIC_SystemReset
                  |L19.134|
000086  2000              MOVS     r0,#0                 ;82
000088  bd7c              POP      {r2-r6,pc}
;;;84     
                          ENDP

00008a  0000              DCW      0x0000
                  |L19.140|
                          DCD      0x4000c000
                  |L19.144|
000090  4572726f          DCB      "Error: Program Config Failed!\n",0
000094  723a2050
000098  726f6772
00009c  616d2043
0000a0  6f6e6669
0000a4  67204661
0000a8  696c6564
0000ac  210a00  
0000af  00                DCB      0
                  |L19.176|
0000b0  63686970          DCB      "chip reset\n",0
0000b4  20726573
0000b8  65740a00

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __FUNCTION__
000000  456d756c          DCB      0x45,0x6d,0x75,0x6c
000004  6174655f          DCB      0x61,0x74,0x65,0x5f
000008  45455052          DCB      0x45,0x45,0x50,0x52
00000c  4f4d5f57          DCB      0x4f,0x4d,0x5f,0x57
000010  72697465          DCB      0x72,0x69,0x74,0x65
000014  54657374          DCB      0x54,0x65,0x73,0x74
000018  00                DCB      0x00
                  |symbol_number.60|
000019  456d75            DCB      0x45,0x6d,0x75
00001c  6c617465          DCB      0x6c,0x61,0x74,0x65
000020  5f454550          DCB      0x5f,0x45,0x45,0x50
000024  524f4d5f          DCB      0x52,0x4f,0x4d,0x5f
000028  52656164          DCB      0x52,0x65,0x61,0x64
00002c  54657374          DCB      0x54,0x65,0x73,0x74
000030  00                DCB      0x00

                          AREA ||.data||, DATA, ALIGN=2

                  incr_base
000000  0000              DCB      0x00,0x00
                  ||CNT||
000002  0000              DCW      0x0000
                  CNT_read
000004  0000              DCW      0x0000
                  CNT_write
000006  0000              DCW      0x0000
                  BitFlag
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_BitFlag____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_main_c_BitFlag____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_BitFlag____REVSH|
#line 402
|__asm___6_main_c_BitFlag____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_BitFlag____RRX|
#line 587
|__asm___6_main_c_BitFlag____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
